#include <vsm/impl/codegen.hpp>

#include <format>
#include <span>

using namespace vsm;
using namespace vsm::lexgen;

namespace {

struct token
{
	std::string_view prefix;
	rule const* rule;
};

} // namespace

template<>
struct std::formatter<token>
{
	template<typename FormatContext>
	auto format(token const& token, FormatContext& context) const
	{
		if (rule != nullptr)
		{
			context.advance_to(std::format_to(context.out(),
				"{}_token({})", token.prefix, token.rule->name_token->content));
		}
		else
		{
			context.advance_to(std::format_to(context.out(),
				"{}_error", token.prefix));
		}
	}
};


std::string lexgen::generate(state_machine const& machine, std::string_view const prefix)
{
	std::string code;

	auto const write = [&](auto const&... args)
	{
		std::format_to(std::back_inserter(code), args...);
	};


	size_t const class_count = machine.class_count;

	write("/* This code was generated by vsm-lexgen. */\n\n");
	write("#pragma once\n\n");

	write("#define {}_class_count {}\n", prefix, machine.class_count);
	write("#define {}_state_count {}\n", prefix, machine.state_count);
	write("\n");

	write("#define {}_class_table(X) \\\n", prefix);
	for (size_t i = 0; i < 0x10; ++i)
	{
		write("\t");
		for (size_t j = 0; j < 0x10; ++j)
		{
			write("X({:#02X}) ", machine.input_to_class[i * j]);
		}
		write("\\\n");
	}
	write("\n");

	auto const write_transition = [&](state const* const state, size_t const input_class)
	{
		transition const transition = state->transitions[input_class];
	
		if (transition.accept)
		{
			write("A({}, {}) ", state->index, token{ prefix, state->rule });
		}
		else
		{
			write("T({}) ", state->index);
		}
	};

	write("#define {}_state_major(B, T, A, E) \\\n", prefix);
	for (state const* const state : std::span(machine.states, machine.state_count))
	{
		write("\tB ");
		for (size_t i = 0; i < class_count; ++i)
		{
			write_transition(state, i);
		}
		write("E \\\n");
	}
	write("\n");

	write("#define {}_class_major(XT, XA, XS) \\\n", prefix);
	for (size_t i = 0; i < class_count; ++i)
	{
		write("\tB ");
		for (state const* const state : std::span(machine.states, machine.state_count))
		{
			write_transition(state, i);
		}
		write("E \\\n");
	}
	write("\n");

	write("#define {}_eof(X) \\\n", prefix);
	for (state const* const state : std::span(machine.states, machine.state_count))
	{
		write("X({}) \\\n", token{ prefix, state->rule });
	}
	write("\n");

	return code;
}
